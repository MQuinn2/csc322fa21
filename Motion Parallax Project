<body>
<canvas id="canvas"  width="500" height="500">
</canvas>
<script 
src="https://threejs.org/build/three.js">     
</script>
</body>



//js
const renderer = new THREE.WebGLRenderer({
  canvas: canvas
});
const fov = 100;
const aspect = 1;
const near = 0.1;
const far = 5;
const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
camera.position.z = 2;
const scene = new THREE.Scene();

const backgroundGeometry = new THREE.PlaneGeometry(7, 7);
const background = new THREE.MeshBasicMaterial({
  color: 0x87ceeb
});
const plane = new THREE.Mesh(backgroundGeometry, background);

//ellipse function I made for the sun and branches
function ellipse(x, y, width, height, curve, color, array) {
  var ell = new THREE.Shape();
  ell.moveTo(x, y)
    .bezierCurveTo(x, y, x + (1 + curve) * width, y + (1 - curve) * height, x + 2 * width, y + 2 * height)
    .bezierCurveTo(x + 2 * width, y + 2 * height, x + (1 + curve) * width, y + (3 + curve) * height, x, y + 4 * height)
    .bezierCurveTo(x, y + 4 * height, x - (1 + curve) * width, y + (3 + curve) * height, x - 2 * width, y + 2 * height)
    .bezierCurveTo(x - 2 * width, y + 2 * height, x - (1 + curve) * width, y + (1 - curve) * height, x, y);
  const ellGeometry = new THREE.ShapeGeometry(ell);
  const ellMaterial = new THREE.MeshBasicMaterial({
    color: color
  });
  const ellMesh = new THREE.Mesh(ellGeometry, ellMaterial);
  array.push(ellMesh);
  scene.add(ellMesh);
}

//sun
var sunArray = []; //just made for consistency, not really needed
ellipse(1.3, 1.7, 0.15, 0.15, 0.9, 0xFFFF00, sunArray);

//mountains
var mountain0 = new THREE.Shape();
mountain0.moveTo(0, 1.2, 5)
  .lineTo(-1, -2.5)
  .lineTo(1, -2.5);
var mountain1 = new THREE.Shape();
mountain1.moveTo(1.3, 0.5)
  .lineTo(0, -2.5)
  .lineTo(2.6, -2.5);
var mountain2 = new THREE.Shape();
mountain2.moveTo(-0.6, 0.7)
  .lineTo(0.8, -2.5)
  .lineTo(-2.8, -2.5);
const mountainGeometry0 = new THREE.ShapeGeometry(mountain0);
const mountainGeometry1 = new THREE.ShapeGeometry(mountain1);
const mountainGeometry2 = new THREE.ShapeGeometry(mountain2);
const mountainMaterial0 = new THREE.MeshBasicMaterial({
  color: Math.random() * 100000000
});
const mountainMaterial1 = new THREE.MeshBasicMaterial({
  color: Math.random() * 100000000
});
const mountainMaterial2 = new THREE.MeshBasicMaterial({
  color: Math.random() * 100000000
});
const mountainMesh0 = new THREE.Mesh(mountainGeometry0, mountainMaterial0);
const mountainMesh1 = new THREE.Mesh(mountainGeometry1, mountainMaterial1);
const mountainMesh2 = new THREE.Mesh(mountainGeometry2, mountainMaterial2);
scene.add(plane, mountainMesh0, mountainMesh1, mountainMesh2);

//grass (foreground)
const grassX = 1.3,
  grassY = 1.7;
var grass = new THREE.Shape();
grass.moveTo(-4, -2)
  .lineTo(4, -2)
  .lineTo(4, -3)
  .lineTo(-4, -3);
const grassGeometry = new THREE.ShapeGeometry(grass);
const grassMaterial = new THREE.MeshBasicMaterial({
  color: 0x00FF00
});
const grassMesh = new THREE.Mesh(grassGeometry, grassMaterial);
scene.add(grassMesh);

//grass blades
var bladePoints = [];
var bladeArray = [];
const bladeMaterial = new THREE.LineBasicMaterial({
  color: 0x00FF00
});
for (i = 0; i < 60; i++) {
  bladePoints.push(new THREE.Vector3(-3 + i * 0.1, -2, 0));
  bladePoints.push(new THREE.Vector3(-3 + i * 0.1, -1.8, 0));
  var bladeGeometry = new THREE.BufferGeometry().setFromPoints(bladePoints);
  var line = new THREE.Line(bladeGeometry, bladeMaterial);
  bladeArray.push(line);
  scene.add(line);
  bladePoints.pop();
  bladePoints.pop();
}

//tree
//trunk
var branchArray = [];
const trunk = new THREE.Shape();
trunk.moveTo(2, -2.2)
  .lineTo(1.85, -2.2)
  .lineTo(1.85, -2)
  .lineTo(2, -2);
const trunkGeometry = new THREE.ShapeGeometry(trunk);
const trunkMaterial = new THREE.MeshBasicMaterial({
  color: 0x964B00
});
const trunkMesh = new THREE.Mesh(trunkGeometry, trunkMaterial);
scene.add(trunkMesh);
//branches
ellipse(1.925, -2.05, 0.10, 0.08, 0.9, 0x0B4704,branchArray);
ellipse(1.925, -1.8, 0.08, 0.06, 0.9, 0x0B4704, branchArray);
ellipse(1.925, -1.60, 0.06, 0.04, 0.9, 0x0B4704, branchArray);

//birds
var birdArray = [];
function bird(x, y, size) {
  var ySize = size;
  for (i = 0; i < 2; i++) {
    const curve = new THREE.QuadraticBezierCurve(
      new THREE.Vector2(x, y),
      new THREE.Vector2(x + size, y + 2 * ySize),
      new THREE.Vector2(x + 2 * size, y + 0.5 * ySize)
    );
    const birdPoints = curve.getPoints(50);
    const birdGeometry = new THREE.BufferGeometry().setFromPoints(birdPoints);
    const birdMaterial = new THREE.LineBasicMaterial({
      color: 0x000000
    });
    var curveObject = new THREE.Line(birdGeometry, birdMaterial)
    birdArray.push(curveObject);
    scene.add(curveObject);
    size = -size;
  }
}
//bird placement
bird(-3.7, 1.2, 0.1);
bird(-3.2, 1.1, 0.1);
bird(-2.7, 1, 0.1);
bird(-3.2, 0.9, 0.1);
bird(-3.7, 0.8, 0.1);

renderer.render(scene, camera);


raycaster = new THREE.Raycaster();
mouse = new THREE.Vector2()
document.addEventListener('mousemove', onDocumentMouseMove, false);

function onDocumentMouseMove(event) {
  event.preventDefault();
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
}

var objects = raycaster.intersectObjects(scene.children);

function animate() {
  requestAnimationFrame(animate);
  //layer 1
  sunArray[0].position.x += mouse.x * 0.1 - sunArray[0].position.x;
  sunArray[0].position.y += mouse.y * 0.1 - sunArray[0].position.y;
  //layer 2
  mountainMesh0.position.x += mouse.x * 0.2 - mountainMesh0.position.x;
  mountainMesh0.position.y += mouse.y * 0.2 - mountainMesh0.position.y;
  //layer 3
  mountainMesh1.position.x += mouse.x * 0.3 - mountainMesh1.position.x;
  mountainMesh1.position.y += mouse.y * 0.3 - mountainMesh1.position.y;
  mountainMesh2.position.x += mouse.x * 0.3 - mountainMesh2.position.x;
  mountainMesh2.position.y += mouse.y * 0.3 - mountainMesh2.position.y;
  //layer 4
  grassMesh.position.x += mouse.x * 0.5 - grassMesh.position.x;
  grassMesh.position.y += mouse.y * 0.5 - grassMesh.position.y;
  for(i = 0; i < bladeArray.length; i++)
  {
  	bladeArray[i].position.x += mouse.x * 0.5 - bladeArray[i].position.x;
    bladeArray[i].position.y += mouse.y * 0.5 - bladeArray[i].position.y;
  }
  trunkMesh.position.x += mouse.x * 0.5 - trunkMesh.position.x;
  trunkMesh.position.y += mouse.y * 0.5 - trunkMesh.position.y;
  for(i = 0; i < branchArray.length; i++)
  {
  	branchArray[i].position.x += mouse.x * 0.5 - branchArray[i].position.x;
    branchArray[i].position.y += mouse.y * 0.5 - branchArray[i].position.y;
  }

//bird movement
  var i = 0;
  while(i <= 9) //A while loop was specified
  {
 		birdArray[i].position.x += 0.01;
    i++;
  }
  // sends birds back to the left after reaching the right side
  // nested loops could have been used, but I did this for more clarity
  if (birdArray[5].position.x >= 5.7)
  {
    for(i = 0; i <= 9; i++)
    {
 		  birdArray[i].position.x = -3;
    }
  }
  renderer.render(scene, camera);
}
animate();
